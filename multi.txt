Αρχικά με την δημιουργία του κάθε νήματος μπαίνει σε while(1) βρόγχο και περιμένει, αν η ουρά του έχει αδειάσει.
Επίσης περιμένει αν η κατάσταση του scheduler είναι "wait" και δεν έχει δουλειά να εκτελέσει.
Ο scheduler μπορεί να έχει 3 καταστάσεις, "destroy", "wait" και "running"

Η κατάσταση destroy σημαίνει ότι πρέπει αφού όλα τα threads ολοκληρώσουν τις δουλείες τους να γίνει cancel αυτών και να απελευθερωθεί ομαλά η μνήμη που είχε δεσμευτεί.

Η κατάσταση wait σημαίνει ότι ο scheduler περιμένει όλα τα threads να ολοκληρώσουν τις δουλειές τους για να πάρει τα αποτελέσματα στην σειρά που τα θέλει.

Όταν είναι σε κατάσταση wait τα threads που δεν έχουν δουλειά περιμένουν πάνω σε ενα conditional variable pool_barrier.

Γίνεται επίσης η χρήση ενός mutex για access πάνω στις δομές, και αλλά 2 conditional variables.
Το πρώτο (pool_queue_empty) δηλώνει ότι η ουρά με τις δουλείες είναι άδεια και πρέπει τα threads να περιμένουν.
Το δεύτερο (pool->pool_cleanup) δηλώνει ότι πρέπει για να καταστρέψει ο scheduler το pool να περιμένει να κάνουν cleanup όλοι οι workers.

Η ουρά με τις δουλειές είναι μια απλά συνδεδεμένη λίστα με δείκτες στο τέλος και στην αρχή για O(1) εισαγωγή και διαγραφή.
Σαν μέλη της έχει έναν δείκτη σε συνάρτηση (το job), έναν δείκτη στα ορίσματα του job και έναν δείκτη στο επόμενο job.


Multithread sort-merge : Εφόσον χρησιμοποιούμε μη-αναδρομική sort και κρατάμε σε μια ουρά τα base, size των ιστογραμμάτων και τον psum είναι εύκολο να γίνει ο διαχωρισμός των buckets και η επιστροφή αυτών στην merge. Παρόλαυτα, μπορεί η sort να σπάσει σε 2 buckets τους αριθμούς και να είναι μικρή η σχέση οπότε να τα κάνει quicksort απευθείας. Σε τέτοιες περιπτώσεις αποφεύγουμε την δημιουργία των threads καθώς το overhead απλά θα υπερκάλπυτε μια quicksort με δεδομένα που χωράνε στην cache. 

Επίσης παρατηρήσαμε ότι στα δεδομένα που δόθηκαν το σπάσιμο σε παραπάνω από 1 bucket γίνεται μετά από το k-byte, k != 1. Οπότε προχωράμε με 1 thread όσο σπάει σε 1 bucket και αν την πρώτη φορά σπάσει σε έναν ικανοποιητικό αριθμό από buckets (π.χ. > 20) τότε δημιουργούμε threads και αναλαμβάνουν αυτά να εκτελέσουν το sort, το καθένα ένα πλήθος από buckets. Μετά η merge χρησιμοποιεί αυτά τα ίδια buckets για να εκτελέσει και η ίδια παράλληλα το join.
Συνεπώς ο πολυνηματισμός της sort-merge εξαρτάται από το πλήθος των δεδομένων.
Αν γίνει multi-threaded η sort, θα γίνει και η join αλλιώς καμία από τις 2.

Εισάγαμε επίσης μια νέα μορφή πολυνηματισμού, το να παραλληλοποιήσουμε τις κλήσεις των 2 sort πριν από κάθε join.

Έχουμε επίσης την μορφή πολυνηματισμού για queries.

Για κάθε μία από αυτές τις 3 μορφές δεσμεύουμε 2-3 threads εκτός αν δεν οριστούν κάποιες μορφές οπότε ορίζουμε 7 threads για τα queries μόνο.

Για παράδειγμα : Έστω ότι κάνουμε πολυνηματισμό στην sort-merge (εσωτερικά) και στα queries.
		 Τότε δεσμεύουμε 3 threads για τα queries και 2 για την sort-merge.

		 Έστω ότι κάνουμε πολυνηματισμό μόνο στα queries, τότε δίνουμε 7 threads στα queries, κλπ.


Παρακάτω παρουσίαζουμε σχέσεις χρόνου εκτέλεσης - μνήμης.

	Περίπτωση 1 - Όλα single-threaded
		
		  Χρόνος εκτέλεσης small : (seconds)
	 	  Μνήμη small : (bytes)
		  
		  Χρόνος εκτέλεσης medium : (seconds)
	 	  Μνήμη medium : (bytes)

	Περίπτωση 2 - Παραλληλία μόνο σε επίπεδο queries
		  
		  Χρόνος εκτέλεσης small : (seconds)
	 	  Μνήμη small : (bytes)
		  
		  Χρόνος εκτέλεσης medium : (seconds)
	 	  Μνήμη medium : (bytes)
	
	Περίπτωση 3 - Παραλληλία σε επίπεδο queries, sort-merge

		  Χρόνος εκτέλεσης small : (seconds)
	 	  Μνήμη small : (bytes)
		  
		  Χρόνος εκτέλεσης medium : (seconds)
	 	  Μνήμη medium : (bytes)

	Περίπτωση 4 - Παραλληλία σε επίπεδο queries, sort-merge, sort_call (εκτέλεση 2 παράλληλων sort)

		  Χρόνος εκτέλεσης small : (seconds)
	 	  Μνήμη small : (bytes)
		  
		  Χρόνος εκτέλεσης medium : (seconds)
	 	  Μνήμη medium : (bytes)
	
	Περίπτωση 5 - Παραλληλία σε επίπεδο sort-merge, sort_call

		  Χρόνος εκτέλεσης small : (seconds)
	 	  Μνήμη small : (bytes)
		  
		  Χρόνος εκτέλεσης medium : (seconds)
	 	  Μνήμη medium : (bytes)

	Περίπτωση 6 - Παραλληλία μόνο σε επίπεδο sort_merge

		  Χρόνος εκτέλεσης small : (seconds)
	 	  Μνήμη small : (bytes)
		  
		  Χρόνος εκτέλεσης medium : (seconds)
	 	  Μνήμη medium : (bytes)

	Περίπτωση 7 - Παραλληλία μόνο σε επίπεδο sort_call

		  Χρόνος εκτέλεσης small : (seconds)
	 	  Μνήμη small : (bytes)
		  
		  Χρόνος εκτέλεσης medium : (seconds)
	 	  Μνήμη medium : (bytes)

	Περίπτωση 8 - Παραλληλία σε επίπεδο queries, sort_call

		  Χρόνος εκτέλεσης small : (seconds)
	 	  Μνήμη small : (bytes)
		  
		  Χρόνος εκτέλεσης medium : (seconds)
	 	  Μνήμη medium : (bytes)


Αυτά τα test cases ήταν εύκολο να υλοποιηθούν με ελάχιστα παραπάνω κώδικα (δεν αντιγράψαμε τις συναρτήσεις) χρησιμοποιώντας conditional compilation.

Πιο συγκεκριμένα, ορίζουμε με -D κάποιες σταθερές και κατά την διάρκεια της μεταγλώτισης παράγεται ο κατάλληλος κώδικας.

Για παράδειγμα, για να εκτελεστεί παραλληλία μόνο σε επίπεδο queries αρκεί να ορίσουμε στο Makefile 
 -DMULTITHREAD_QUERIES και καμία άλλη σταθερά.

Αν θέλουμε παραλληλία σε queries και sort-merge ορίζουμε την -DMULTITHREAD_SORT και την -DMULTITHREAD_QUERIES κλπ.

Βελτιώσεις από την φάση 2 : Στην εργασία της φάσης 2 είχαμε πολλές καθυστερήσεις και χρησιμοποιούσαμε πολύ παραπάνω μνήμη. Για παράδειγμα, το small έκανε 2.30 λεπτά ένω τώρα 1.2 δευτερόλεπτα.

Πιο συγκεκριμένα, αλλάξαμε τον τρόπο που τροποποιούμε τα ενδιάμεσα αποτελέσματα μετά από κάθε join και χρησιμοποιήσαμε διαφορετικό generic array από την φάση 2 διότι το generic array της φάσης 2 χρησιμοποιούσε void * για να αποθηκεύει τα δεδομένα και απαιτούσε παραπάνω χώρο διότι κρατούσε πολλές παραπάνω πληροφορίες και επειδή οι δείκτες του ήταν διάσκορποι στην μνήμη και όχι σε συνεχόμενη σειρά είχαμε πολλά cache miss.

Το νέο array που χρησιμοποιήσαμε αποθηκεύει τα δεδομένα όπως τα συνηθισμένα arrays (σε συνεχόμενη σειρά).

Τα queries εκτελούνται ανά batch.


Join enumeration και στατιστικά : ... all yours

